package metric.correlation.analysis.vulnerabilities;

import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.client.RequestOptions;

import com.google.gson.Gson;

import metric.correlation.analysis.database.ElasticSearchHelper;
import metric.correlation.analysis.vulnerabilities.cve.data.CVE;
import metric.correlation.analysis.vulnerabilities.cve.data.CVEPage;
import metric.correlation.analysis.vulnerabilities.cve.data.CVSSData;
import metric.correlation.analysis.vulnerabilities.cve.data.CVSSMetricV2;
import metric.correlation.analysis.vulnerabilities.cve.data.Description;
import metric.correlation.analysis.vulnerabilities.cve.data.Vulnerability;

/**
 * Imports the NVD database into a local Elasticsearch database.
 *
 * @author Antoniya Ivanova
 * @author Sven Peldszus
 *
 */

public class VulnerabilityDataImporter {

	private static final String NVD_NIST_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0";
	private static final String NVD_NIST_PARAM_START = "startIndex=";
	private static final String NVD_NIST_PARAM_RESULTS = "resultsPerPage=";
	private static final int NVD_NIST_PARAM_RESULTS_VALUE = 2000;

	private static final Logger LOGGER = Logger.getLogger(VulnerabilityDataImporter.class);

	protected static String vulnerabilityDatabaseName = "vulnerability_database";

	public static void main(final String[] args) throws IOException {
		final var consoleAppender = new ConsoleAppender();
		final var PATTERN = "%m%n";
		consoleAppender.setLayout(new PatternLayout(PATTERN));
		consoleAppender.setThreshold(Level.INFO);
		consoleAppender.activateOptions();
		Logger.getRootLogger().addAppender(consoleAppender);
		new VulnerabilityDataImporter().addCVEsToElastic();
	}

	/**
	 * Adds a list of Documents to the Elastic Database (index) at
	 * {@value vulnerabilityDatabaseName}.
	 *
	 * @throws IOException If a document cannot be added
	 */
	public void addCVEsToElastic() throws IOException {
		var index = 0;
		var more = true;
		do {
			System.out.print("Get batch from " + index + " to " + (index + NVD_NIST_PARAM_RESULTS_VALUE - 1));
			try (final var stream = new URL(
					NVD_NIST_URL + '?' + NVD_NIST_PARAM_RESULTS + NVD_NIST_PARAM_RESULTS_VALUE + '&'
							+ NVD_NIST_PARAM_START + index)
					.openStream()) {
				final var content = new Gson().fromJson(new InputStreamReader(stream), CVEPage.class);
				final var totalResults = content.getTotalResults();
				System.out.println(" of " + totalResults);
				more = content.getResultsPerPage() >= NVD_NIST_PARAM_RESULTS_VALUE;
				this.processCVEs(content);
				index += NVD_NIST_PARAM_RESULTS_VALUE;
			}
		} while (more);
	}

	private void processCVEs(final CVEPage data) {
		for (final var vulnerability : data.getVulnerabilities()) {
			this.indexInElasticsearch(this.processCVEItem(vulnerability));
		}
	}

	private List<Map<String, Object>> processCVEItem(final Vulnerability cveItem) {
		final var cve = cveItem.getCve();
		if ("Rejected".equalsIgnoreCase(cve.getVulnerabilityStatus())) {
			return Collections.emptyList();
		}
		final var ID = cve.getID();

		final var products = this.getVulnerableProducs(cve);
		if (products.isEmpty()) {
			return Collections.emptyList();
		}

		final var description = cve.getDescriptions().stream().filter(d -> "en".equals(d.getLanguage()))
				.map(Description::getValue).findAny().orElse("");

		final var metrics = cve.getMetrics();
		final double cvss3 = -1;
		if (metrics.getCVSSv3() != null) {
			for (final var metric : metrics.getCVSSv3()) {

			}
			// TODO
		}

		final double cvss2 = -1;
		if (metrics.getCVSSv2() != null) {
			metrics.getCVSSv2().stream().map(CVSSMetricV2::getCVSSData)
					.mapToDouble(CVSSData::getBaseScore).average().orElse(-1);
		}

		// Prepare Elastic Document
		final var elements = new LinkedList<Map<String, Object>>();
		for (final var vendorEntry : products.entrySet()) {
			for (final var productEntry : vendorEntry.getValue().entrySet()) {
				final var jsonMap = new HashMap<String, Object>();
				jsonMap.put("ID", ID);
				jsonMap.put("Vendor", vendorEntry.getKey().toLowerCase().replace("-", "").replace("_", ""));
				jsonMap.put("Product", productEntry.getKey().toLowerCase().replace("-", "").replace("_", ""));
				jsonMap.put("Versions", productEntry.getValue());
				jsonMap.put("CVSS2_baseScore", cvss2);
				jsonMap.put("CVSS3_baseScore", cvss3);
				jsonMap.put("Description", description.toLowerCase().replace("-", "").replace("_", ""));
				elements.add(jsonMap);
			}
		}
		return elements;
	}

	private Map<String, Map<String, Set<String>>> getVulnerableProducs(final CVE cve) {
		final var products = new HashMap<String, Map<String, Set<String>>>();

		final var configurations = cve.getConfigurations();
		if (configurations == null || configurations.isEmpty()) {
			// No vulnerable configurations in the CPE
			return Collections.emptyMap();
		}
		for (final var configuration : configurations) {
			for (final var node : configuration.getNodes()) {
				final var cpes = node.getCPEMatches();
				if ((cpes == null) || cpes.isEmpty()) {
					// No referenced CPEs
					return Collections.emptyMap();
				}
				for (final var cpe : cpes) {
					if (cpe.getVulnerable()) {
						final var criteria = cpe.getCriteria().split(":");
						final var vendor = products.computeIfAbsent(criteria[3],
								v -> new HashMap<String, Set<String>>());
						final var product = vendor.computeIfAbsent(criteria[4], p -> new HashSet<>());
						if ((criteria.length > 4)) {
							product.add(criteria[5]);
						} else {
							product.add("*");
						}
					}
				}
			}
		}
		return products;
	}

	private void indexInElasticsearch(final List<Map<String, Object>> documents) {
		try (final var client = ElasticSearchHelper.getElasticSearchClient()) {

			final var iterator = documents.iterator();
			while (iterator.hasNext()) {
				try {
					client.index(new IndexRequest(vulnerabilityDatabaseName, "_doc").source(iterator.next()),
							RequestOptions.DEFAULT);
				} catch (final Exception e) {
					LOGGER.log(Level.ERROR, "Could not index document " + iterator.toString());
					LOGGER.log(Level.ERROR, e.getMessage(), e);
				}

			}
		} catch (final IOException e) {
			LOGGER.log(Level.ERROR, e.getMessage(), e);
		}
	}
}

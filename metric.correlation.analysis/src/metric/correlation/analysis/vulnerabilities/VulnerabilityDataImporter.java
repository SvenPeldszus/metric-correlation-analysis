package metric.correlation.analysis.vulnerabilities;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.http.HttpHost;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.gravity.eclipse.io.FileUtils;
import org.gravity.eclipse.io.ZipUtil;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonReader;

/**
 * @author Antoniya Ivanova Imports the NVD database into a local Elasticsearch
 *         database.
 *
 */

public class VulnerabilityDataImporter {

	private static final Logger LOGGER = Logger.getLogger(VulnerabilityDataImporter.class);

	private static String feedsLocation = "JSONfeeds";
	private static String NVDfeedsLink = "https://nvd.nist.gov/vuln/data-feeds#JSON_FEED";
	protected static String vulnerabilityDatabaseName = "vulnerability_database";

	public static void main(String[] args) {
		ConsoleAppender consoleAppender = new ConsoleAppender();
		String PATTERN = "%m%n";
		consoleAppender.setLayout(new PatternLayout(PATTERN));
		consoleAppender.setThreshold(Level.INFO);
		consoleAppender.activateOptions();
		Logger.getRootLogger().addAppender(consoleAppender);
		new VulnerabilityDataImporter();
	}

	public VulnerabilityDataImporter() {
		addDocumentsToElastic();

		LOGGER.log(Level.INFO, "Deleting raw JSON Feeds files.");
		if (!FileUtils.recursiveDelete(new File(feedsLocation))) {
			LOGGER.log(Level.ERROR, "Couldn't delete the JSON feeds!");
		}
	}

	/**
	 * Gets the JSON feeds URL from the NVD web site.
	 * 
	 * @return An ArrayList of NVD JSON feed URLs
	 */
	private ArrayList<URL> getJSONFeedURLs() {
		URL url;
		String line;

		ArrayList<URL> urls = new ArrayList<>();
		String result = "";
		URL resultURL = null;

		try {
			url = new URL(NVDfeedsLink);
			try (InputStream is = url.openStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is))) {

				while ((line = br.readLine()) != null) {
					if (line.contains(".json.zip")) {
						result = line.trim().replace("<a href='", "");
						result = result.replace("' target='_blank'>ZIP</a>", "");

						resultURL = new URL(result);
						urls.add(resultURL);
					}
				}
			}
		} catch (Exception e) {
			LOGGER.log(Level.ERROR, e.getMessage(), e);
		}

		return urls;
	}

	/**
	 * Downloads the JSON feeds from the NVD web site as ZIP files, un-ZIPs them and
	 * deletes the ZIP files.
	 */
	private void downloadJSONFeeds() {
		FileUtils.createDirectory(feedsLocation);
		ArrayList<URL> urls = getJSONFeedURLs();

		for (Iterator<URL> iterator = urls.iterator(); iterator.hasNext();) {
			URL url = iterator.next();
			String fileName = url.toString().substring(40);
			LOGGER.log(Level.INFO, "Downloading " + fileName);

			try {
				org.apache.commons.io.FileUtils.copyURLToFile(url, new File(feedsLocation + File.separator + fileName));
			} catch (IOException e) {
				LOGGER.log(Level.ERROR, e.getMessage(), e);
			}

			String unzipLocation = feedsLocation;
			String zipFilePath = feedsLocation + File.separator + fileName;
			LOGGER.log(Level.INFO, "Unzipping " + fileName);
			ZipUtil.unzip(zipFilePath, unzipLocation);
		}

		LOGGER.log(Level.INFO, "Download finished");

		LOGGER.log(Level.INFO, "Deleting ZIP files");
		File[] ZIPfiles = new File(feedsLocation).listFiles();
		for (File file : ZIPfiles) {
			if (file.getName().contains("zip") || file.getName().contains("modified")
					|| file.getName().contains("recent"))
				file.delete();
		}

	}

	/**
	 * Parses the JSON files in {@value feedsLocation}.
	 * 
	 * @return An ArrayList of HashMaps to be added to the Elastic database (index)
	 */
	private ArrayList<HashMap<String, Object>> parseJSONFilesToDocuments() {
		ArrayList<HashMap<String, Object>> documentsForElastic = new ArrayList<HashMap<String, Object>>();
		File[] jsonFiles = new File(feedsLocation).listFiles();

		String vendor = "", product = "";

		for (File file : jsonFiles) {

			try {
				Gson gson = new GsonBuilder().create();
				JsonReader jsonReader = new JsonReader(
						new InputStreamReader(new FileInputStream((file.getPath())), "UTF-8"));

				Vulnerability vulnerabilityFile = gson.fromJson(jsonReader, Vulnerability.class);
				List<metric.correlation.analysis.vulnerabilities.CVEItem> vulnerabilities = vulnerabilityFile
						.getCVEItems();

				for (CVEItem cveItem : vulnerabilities) {

					List<String> versions = new ArrayList<String>();

					// Vendor data is empty
					if (cveItem.getCve().getAffects().getVendor().getVendorData().isEmpty()) {
						// Nodes is empty
						if ((cveItem.getConfigurations().getNodes().isEmpty())) {
							continue;
						} else {
							// Cpe is null
							if (cveItem.getConfigurations().getNodes().get(0).getCpe() == null) {
								continue;
								// Cpe is empty
							} else if (cveItem.getConfigurations().getNodes().get(0).getCpe().isEmpty()) {
								continue;
							} else {
								String[] productAndVendor = cveItem.getConfigurations().getNodes().get(0).getCpe()
										.get(0).getCpe22Uri().split(":");
								vendor = productAndVendor[2];
								product = productAndVendor[3];

								for (Cpe cpe : cveItem.getConfigurations().getNodes().get(0).getCpe()) {
									if (cpe.getVulnerable() && cpe.getCpe22Uri().split(":").length > 4) {
										versions.add(cpe.getCpe22Uri().split(":")[4]);
									} else {
										versions.add("*");
									}
								}
							}
						}
					} else {

						vendor = cveItem.getCve().getAffects().getVendor().getVendorData().get(0).getVendorName()
								.toString();

						product = cveItem.getCve().getAffects().getVendor().getVendorData().get(0).getProduct()
								.getProductData().get(0).getProductName().toString();

						List<VersionDatum> versionDatum = cveItem.getCve().getAffects().getVendor().getVendorData()
								.get(0).getProduct().getProductData().get(0).getVersion().getVersionData();

						for (VersionDatum version : versionDatum) {
							versions.add(version.getVersionValue());
						}
					}

					String ID = cveItem.getCve().getCVEDataMeta().getID();

					String description = cveItem.getCve().getDescription().getDescriptionData().get(0).getValue();

					double cvss3 = 0, cvss2 = 0;

					if (cveItem.getImpact().getBaseMetricV3() != null) {
						cvss3 = cveItem.getImpact().getBaseMetricV3().getCvssV3().getBaseScore();
					}

					if (cveItem.getImpact().getBaseMetricV2() != null) {
						cvss2 = cveItem.getImpact().getBaseMetricV2().getCvssV2().getBaseScore();
					}

					// Prepare Elastic Document
					HashMap<String, Object> jsonMap = new HashMap<>();
					jsonMap.put("ID", ID);
					jsonMap.put("Vendor", vendor.toLowerCase().replace("-", "").replace("_", ""));
					jsonMap.put("Product", product.toLowerCase().replace("-", "").replace("_", ""));
					jsonMap.put("Versions", versions);
					jsonMap.put("CVSS2_baseScore", cvss2);
					jsonMap.put("CVSS3_baseScore", cvss3);
					jsonMap.put("Descirpiton", description.toLowerCase().replace("-", "").replace("_", ""));

					documentsForElastic.add(jsonMap);
				}

			} catch (Exception e) {
				LOGGER.log(Level.ERROR, "Error parsing JSON vulnerability file!");
				LOGGER.log(Level.ERROR, e.getMessage(), e);
			}
		}
		return documentsForElastic;

	}

	/**
	 * Adds a list of Documents to the Elastic Database (index) at
	 * {@value vulnerabilityDatabaseName}.
	 */
	private void addDocumentsToElastic() {
		downloadJSONFeeds();
		ArrayList<HashMap<String, Object>> documents = parseJSONFilesToDocuments();
		RestHighLevelClient client = new RestHighLevelClient(
				RestClient.builder(new HttpHost("localhost", 9200, "http")));
		IndexRequest indexRequest = null;

		for (Iterator<HashMap<String, Object>> iterator = documents.iterator(); iterator.hasNext();) {
			indexRequest = new IndexRequest(vulnerabilityDatabaseName, "doc").source(iterator.next());

			try {
				client.index(indexRequest);
			} catch (Exception e) {
				LOGGER.log(Level.ERROR, "Could not index document " + iterator.toString());
				LOGGER.log(Level.ERROR, e.getMessage(), e);
			}

		}

		try {
			client.close();
		} catch (IOException e) {
			LOGGER.log(Level.ERROR, "Could not close RestHighLevelClient!");
			LOGGER.log(Level.ERROR, e.getMessage(), e);
		}

		LOGGER.log(Level.INFO, "Inserting " + documents.size() + " documents into index.");
	}
}

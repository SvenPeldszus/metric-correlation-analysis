package metric.correlation.analysis.vulnerabilities;

import static metric.correlation.analysis.calculation.impl.CVEMetrics.MetricKeysImpl.AVERAGE_CVSS2;
import static metric.correlation.analysis.calculation.impl.CVEMetrics.MetricKeysImpl.AVERAGE_CVSS3;
import static metric.correlation.analysis.calculation.impl.CVEMetrics.MetricKeysImpl.MAX_CVSS2;
import static metric.correlation.analysis.calculation.impl.CVEMetrics.MetricKeysImpl.MAX_CVSS3;
import static metric.correlation.analysis.calculation.impl.CVEMetrics.MetricKeysImpl.NUMBER_OF_VULNERABILITIES;
import static org.elasticsearch.index.query.QueryBuilders.termQuery;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchScrollRequest;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.unit.Fuzziness;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.FuzzyQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.junit.Test;

import info.debatty.java.stringsimilarity.Levenshtein;
import metric.correlation.analysis.configuration.ProjectConfiguration;
import metric.correlation.analysis.database.ElasticSearchHelper;
import metric.correlation.analysis.selection.GitHubProjectSelector;

/**
 * Defines the vulnerability database queries.
 *
 * @author Antoniya Ivanova
 * @author Sven Peldszus
 */

public class VulnerabilityDataQueryHandler {

	private static final String INDEX_NAME = VulnerabilityDataImporter.vulnerabilityDatabaseName;
	private static final String INDEX_TYPE = "_doc";

	private static final Logger LOGGER = Logger.getLogger(VulnerabilityDataQueryHandler.class);

	public static void main(final String[] args) throws IOException {
		final var vul = getVulnerabilities("xmlgraphics-batik", "apache", "*", "AUTO");

		final var projects = getAllProjects();
		System.out.println("Number of repos: " + projects.size());
		final var vulnerable = new HashSet<ProjectConfiguration>();
		final var array = projects.toArray(new ProjectConfiguration[0]);
		for (var i = 0; i < projects.size(); i++) {
			final var project = array[i];
			System.out.println(i + " " + project.getGitUrl());
			// String product, String vendor, final String version, final String fuzziness
			final var product = project.getProductName();
			final var vendor = project.getVendorName();
			final var vulnerabilities = getVulnerabilities(product, vendor, "*",
					"AUTO");
			if (vulnerabilities != null) {
				System.out.println("vulnerabilities: " + vulnerabilities.size());
				vulnerable.add(project);
			}
		}
		System.out.println("Number of repos: " + projects.size());
		System.out.println("Number of vulnerable repos: " + vulnerable.size());
	}

	private static Set<ProjectConfiguration> getAllProjects() throws IOException {
		final var projects = new HashSet<ProjectConfiguration>();
		try (final var elasticClient = ElasticSearchHelper.getElasticSearchClient()) {
			final var searchRequest = new SearchRequest(GitHubProjectSelector.repositoryDatabaseName);
			final var searchSourceBuilder = new SearchSourceBuilder();
			searchSourceBuilder.size(10000);
			searchSourceBuilder.query(QueryBuilders.matchAllQuery());
			searchRequest.source(searchSourceBuilder);
			searchRequest.scroll("15m");
			var response = elasticClient.search(searchRequest, RequestOptions.DEFAULT);
			final var id = response.getScrollId();

			SearchHits hits;
			while ((hits = response.getHits()).getHits().length > 0) {
				System.out.println("Number of hits: " + hits.getHits().length + " projects " + projects.size());
				for (final var hit : hits) {
					final var fields = hit.getSourceAsMap();
					final var product = (String) fields.get("Product");
					final var vendor = (String) fields.get("Vendor");
					final var url = (String) fields.get("URL");
//					System.out.print(url);
					final var exists = projects
							.add(new ProjectConfiguration(product, vendor, url, new HashMap<>()));
//					System.out.println(" " + exists);
				}
				System.out.println("Number of repos: " + projects.size());
				final var request = new SearchScrollRequest(id);
				request.scroll("15m");
				response = elasticClient.searchScroll(request, RequestOptions.DEFAULT);
			}
		}
		return projects;
	}

	/**
	 * Get the vulnerabilities for a given (product, vendor, version, fuzziness)
	 * quadruple.
	 *
	 * @param product   - product name
	 * @param vendor    - the vendor of the product
	 * @param version   - version name as String or * for all versions
	 * @param fuzziness - the fuzziness level of the search
	 *                  ("ZERO","ONE","TWO","AUTO");
	 * @return An ArrayList of the resulting search hits from the database.
	 */
	public static Set<SearchHit> getVulnerabilities(String product, String vendor, final String version,
			final String fuzziness) {
		final var l = new Levenshtein();
		try (final var elasticClient = ElasticSearchHelper.getElasticSearchClient()) {

			// Normalize the input
			product = product.toLowerCase().replace("-", "").replace("_", "");
			vendor = vendor.toLowerCase().replace("-", "").replace("_", "");

			// Search for vulnerabilities by product name first
			final var resultsByProductName = new ArrayList<SearchHit>();

			final var productQuery = buildQuery("Product", product, version, fuzziness);
			final var productHits = search(elasticClient, productQuery);
			if (productHits.length == 0) {
				LOGGER.log(Level.INFO, "No vulnerabilities found for product " + product + ".");
			} else {
				for (final SearchHit hit : productHits) {
					final var searchHitMap = hit.getSourceAsMap();
					if ((l.distance(vendor, (String) searchHitMap.get("Vendor")) <= (vendor.length() / 2))) {
						resultsByProductName.add(hit);
					}
				}
			}

			// Search for remaining vulnerabilities by vendor name
			final var resultsByVendorName = new ArrayList<SearchHit>();

			final var vendorQuery = buildQuery("Vendor", vendor, version, fuzziness);
			final var vendorHits = search(elasticClient, vendorQuery);
			if (vendorHits.length == 0) {
				LOGGER.log(Level.INFO, "No vulnerabilities found for vendor " + vendor + ".");
			} else {
				for (final SearchHit hit : vendorHits) {
					final var searchHitMap = hit.getSourceAsMap();
					if ((l.distance(product, (String) searchHitMap.get("Product")) <= (product.length() / 2))) {
						resultsByVendorName.add(hit);
					}
				}
			}

			final var results = new HashSet<SearchHit>();
			results.addAll(resultsByVendorName);
			results.addAll(resultsByProductName);

			if (!results.isEmpty()) {
				LOGGER.log(Level.INFO, "Found vulnerabilities for " + product);
				for (final SearchHit searchHit : results) {
					final var searchHitMap = searchHit.getSourceAsMap();
					LOGGER.log(Level.INFO, searchHitMap.get("ID"));
				}
			}

			return results;
		} catch (final Exception e) {
			LOGGER.log(Level.ERROR, "Could not close elastic client.");
			LOGGER.log(Level.ERROR, e.getMessage(), e);
		}
		return null;
	}

	private static BoolQueryBuilder buildQuery(final String key, final String value, final String version,
			final String fuzziness) {
		var productQuery = QueryBuilders.boolQuery().must(buildFuzzyQuery(key, value, fuzziness));
		// Add search for version, if given
		if (version.isEmpty()) {
			LOGGER.log(Level.INFO,
					"Searching for vulnerabilities of " + key + ": " + value + ", version " + version + ".");
			productQuery = productQuery.must(termQuery("Versions", version));
		} else {
			LOGGER.log(Level.INFO,
					"Searching for vulnerabilities of " + key + ": " + value + " without version information.");
		}
		return productQuery;
	}

	private static SearchHit[] search(final RestHighLevelClient elasticClient, final BoolQueryBuilder productQuery) {
		final var searchRequest = new SearchRequest(INDEX_NAME).types(INDEX_TYPE);
		final var source = searchRequest.source();
		source.size(5000);
		source.query(productQuery);

		SearchHit[] searchHits;
		try {
			final var searchResponse = elasticClient.search(searchRequest, RequestOptions.DEFAULT);
			searchHits = searchResponse.getHits().getHits();
		} catch (final IOException e) {
			LOGGER.log(Level.ERROR, "Could not get a search response by product name.");
			LOGGER.log(Level.ERROR, e.getMessage(), e);
			searchHits = new SearchHit[0];
		}
		return searchHits;
	}

	private static FuzzyQueryBuilder buildFuzzyQuery(final String type, final String typeName, final String fuzziness) {
		FuzzyQueryBuilder queryBuilder = null;

		switch (fuzziness) {
			case "ZERO":
				queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
						.fuzziness(Fuzziness.ZERO).transpositions(true);
				break;
			case "ONE":
				queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
						.fuzziness(Fuzziness.ONE).transpositions(true);
				break;
			case "TWO":
				queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
						.fuzziness(Fuzziness.TWO).transpositions(true);
				break;
			case "AUTO":
				queryBuilder = QueryBuilders.fuzzyQuery(type, typeName).maxExpansions(4).prefixLength(5)
						.fuzziness(Fuzziness.AUTO).transpositions(true);
				break;
		}

		return queryBuilder;
	}

	/**
	 * @param Documents - A set of documents with the same version project and
	 *                  vendor name
	 * @return A HashMap containing the Metrics for a given set of searchHits
	 */
	public Map<String, String> getMetrics(final Set<SearchHit> documents) {
		final double numberOfVulnerabilities = documents.size();
		var averageCVSS2 = 0D;
		var averageCVSS3 = 0D;
		var maxCVSS2 = 0D;
		var maxCVSS3 = 0D;

		if (numberOfVulnerabilities > 0) {
			for (final SearchHit searchHit : documents) {
				final var searchHitMap = searchHit.getSourceAsMap();
				final var CVSS2 = (double) searchHitMap.get("CVSS2_baseScore");
				final var CVSS3 = (double) searchHitMap.get("CVSS3_baseScore");

				maxCVSS2 = Math.max(CVSS2, maxCVSS2);
				maxCVSS3 = Math.max(CVSS3, maxCVSS3);

				averageCVSS2 += CVSS2;
				averageCVSS3 += CVSS3;
			}

			averageCVSS2 = averageCVSS2 / numberOfVulnerabilities;
			averageCVSS3 = averageCVSS3 / numberOfVulnerabilities;

			if (maxCVSS3 == 0) {
				averageCVSS3 = -1;
				maxCVSS3 = -1;
			}

			if (maxCVSS2 == 0) {
				averageCVSS2 = -1;
				maxCVSS2 = -1;
			}
		}

		final var result = new HashMap<String, String>();
		result.put(NUMBER_OF_VULNERABILITIES.toString(), Double.toString(numberOfVulnerabilities));
		result.put(AVERAGE_CVSS2.toString(), Double.toString(averageCVSS2));
		result.put(AVERAGE_CVSS3.toString(), Double.toString(averageCVSS3));
		result.put(MAX_CVSS2.toString(), Double.toString(maxCVSS2));
		result.put(MAX_CVSS3.toString(), Double.toString(maxCVSS3));
		return result;
	}

	@Test
	public void testVulnerabilitySearch() {
		Logger.getRootLogger().setLevel(Level.ALL);
		final var test = VulnerabilityDataQueryHandler.getVulnerabilities("FileDownloader", "lingochamp", "", "AUTO");
		LOGGER.info("All: " + test.size());
		for (final SearchHit hit : test) {
			LOGGER.info(hit.getSourceAsMap().get("ID"));
		}
	}
}
